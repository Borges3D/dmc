#pragma once
#include "triangle.hpp"
#include <algorithm>
#include <iostream>
#include <vector>

namespace dmc
{
#pragma pack(push)
#pragma pack(1)

	struct stl_header
	{
		char comment[80];
		std::uint32_t num_triangles;
	};

	struct stl_triangle
	{
		vector3f normal;
		vector3f p1;
		vector3f p2;
		vector3f p3;
		std::uint16_t dummy;
	};

#pragma pack(pop)

	template <class Scalar>
	void write_stl(std::ostream& os, const std::vector<triangle<Scalar>>& triangles)
	{
		stl_header header =
			{
				"Generated by dmc",
				static_cast<std::uint32_t>(triangles.size()),
			};

		os.write(reinterpret_cast<const char*>(&header), sizeof(header));

		std::vector<stl_triangle> stl_triangles(triangles.size());

		std::transform(triangles.begin(), triangles.end(), stl_triangles.begin(),
					   [](const auto& t) {
						   stl_triangle result;
						   result.p1 = t.p1().template cast<float>();
						   result.p2 = t.p2().template cast<float>();
						   result.p3 = t.p3().template cast<float>();

						   return result;
					   });

		os.write(reinterpret_cast<const char*>(stl_triangles.data()), sizeof(stl_triangle) * stl_triangles.size());
	}

	template <class Scalar>
	void write_obj(std::ostream& os, const std::vector<triangle<Scalar>>& triangles)
	{

		typename std::vector<triangle<Scalar>>::const_iterator i = triangles.begin();

		os << "o\n";
		for( ; i != triangles.end(); i++ ){
			os << "v " << i->p1().template cast<float>() << "\n";
			os << "v " << i->p2().template cast<float>() << "\n";
			os << "v " << i->p3().template cast<float>() << "\n";
		}
		for( unsigned int f = 0; f < triangles.size(); f++ ){
			os << "f " << ( f * 3 + 1 ) << " " << ( f * 3 + 2 ) << " " << ( f * 3 + 3 ) << "\n";
		}

	}	
}
